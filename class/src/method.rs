//! ```txt
//! Method {
//!     access_flags: u16,
//!     name_index: u16,
//!     descriptor_index: u16,
//!     attributes_count: u16,
//!     attributes: [AttributeInfo; attributes_count],
//! }
//! ```

use crate::{
    attribute::{parse_attribute, AttributeInfo},
    constant::{Constant, PoolIndex},
    field, ByteParser, ClassError, ClassResult,
};

/// Method properties bitfield.
///
/// Interface methods must have their `public` and `abstract` flags set. The may
/// have any of the `bridge`, `varargs`, or `synthetic` flags set.
///
/// Instance initialization methods may have at most one visibility modifier
/// set, as weel as any of the `varargs`, `synthetic`, or `strict` flags. It
/// must have no other flags than these set.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct Access(u16);

impl Access {
    /// Declared abstract; no implementation is provided. If this flag is set
    /// none of the `final`, `native`, `private`, `static`, `strict` or
    /// `synchronized` flags may be set.
    pub const ABSTRACT: Access = Access(0x0400);
    /// A bridge method, generated by the compiler.
    pub const BRIDGE: Access = Access(0x0040);
    /// Declared final; must not be overridden (ยง5.4.5). If this flag is set,
    /// the `abstract` flag must not be set.
    pub const FINAL: Access = Access(0x0010);
    /// Declared native; implemented in a language other than Java. If this flag
    /// is set, the `abstract` flag must not be set.
    pub const NATIVE: Access = Access(0x0100);
    /// Declared private; accessible only within the defining class. If this
    /// flag is set, no other access modifier flags may be set. Additionally,
    /// the `abstract` flag must not be set.
    pub const PRIVATE: Access = Access(0x0002);
    /// Declared protected; may be accessed within subclasses. If this flag is
    /// set, no other access modifier flags may be set.
    pub const PROTECTED: Access = Access(0x0004);
    /// Declared public; may be accessed from outside its package. If this flag
    /// is set, no other access modifier flags may be set.
    pub const PUBLIC: Access = Access(0x0001);
    /// Declared static. If this flag is set, the `abstract` flag must not be
    /// set.
    pub const STATIC: Access = Access(0x0008);
    /// Declared strictfp; floating-point mode is FP-strict. If this flag is
    /// set, the `abstract` flag must not be set.
    pub const STRICT: Access = Access(0x0800);
    /// Declared synchronized; invocation is wrapped by a monitor use.
    pub const SYNCHRONIZED: Access = Access(0x0020);
    /// Declared synthetic; not present in the source code.
    pub const SYNTHETIC: Access = Access(0x1000);
    /// Declared with variable number of arguments.
    pub const VARARGS: Access = Access(0x0080);

    pub fn is(self, access: Access) -> bool {
        self & access != Access(0)
    }

    pub fn into_raw(self) -> u16 {
        self.0
    }
}

impl std::ops::BitAnd for Access {
    type Output = Access;

    fn bitand(self, other: Access) -> Access {
        Access(self.0 & other.0)
    }
}

impl std::ops::BitOr for Access {
    type Output = Access;

    fn bitor(self, other: Access) -> Access {
        Access(self.0 | other.0)
    }
}

impl std::fmt::Display for Access {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let mut was_written = false;
        let mut write = |s| {
            if was_written {
                write!(f, " {}", s)
            } else {
                write!(f, "{}", s)?;
                was_written = true;
                Ok(())
            }
        };

        if self.is(Access::PUBLIC) {
            write("public")?;
        } else if self.is(Access::PROTECTED) {
            write("protected")?;
        } else if self.is(Access::PRIVATE) {
            write("private")?;
        }

        if self.is(Access::ABSTRACT) {
            write("abstract")?;
        } else {
            if self.is(Access::STATIC) {
                write("static")?;
            }

            if self.is(Access::FINAL) {
                write("final")?;
            }

            if self.is(Access::SYNCHRONIZED) {
                write("synchronized")?;
            }

            if self.is(Access::STRICT) {
                write("strictfp")?;
            }

            if self.is(Access::NATIVE) {
                write("native")?;
            }
        }

        Ok(())
    }
}

#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub enum ReturnDescriptor {
    Void,
    Type(field::Descriptor),
}

#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub struct Descriptor {
    pub ret: ReturnDescriptor,
    pub args: Box<[field::Descriptor]>,
}

pub fn parse_method_descriptor(input: &mut ByteParser<'_>) -> ClassResult<Descriptor> {
    input.tag(b"(")?;

    let mut args = Vec::new();
    loop {
        args.push(match input.peek(1)?[0] {
            b')' => break,
            _ => field::parse_field_descriptor(input)?,
        });
    }

    input.tag(b")")?;

    let ret = match input.peek(1)?[0] {
        b'V' => ReturnDescriptor::Void,
        _ => ReturnDescriptor::Type(field::parse_field_descriptor(input)?),
    };

    Ok(Descriptor {
        ret,
        args: args.into(),
    })
}

pub fn parse_method(input: &mut ByteParser<'_>, pool: &[Constant]) -> ClassResult<Method> {
    let access = Access(input.parse_u16()?);
    let name = input.parse_u16()? as usize;
    let descriptor_index = input.parse_u16()? as usize;
    let descriptor = match pool[descriptor_index].as_string_data() {
        Some(data) => parse_method_descriptor(&mut ByteParser::new(data.as_bytes())),
        _ => Err(ClassError::InvalidPoolType),
    }?;

    let attributes_len = input.parse_u16()? as usize;
    let attributes = input.seq(attributes_len, |input| parse_attribute(input, pool))?;

    Ok(Method {
        access,
        name,
        descriptor,
        attributes: attributes.into(),
    })
}

#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub struct Method {
    /// Method properties
    pub access: Access,
    /// Index into the constant pool, pointing to a `Constant::StringData` that
    /// denotes the name of the method.
    pub name: PoolIndex,
    /// Index into the constant pool, pointing to a `Constant::StringData` that
    /// denotes the method signature.
    pub descriptor: Descriptor,
    pub attributes: Box<[AttributeInfo]>,
}
