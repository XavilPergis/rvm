//! # Class file binary format
//!
//! All numbers in this format are big-endian
//!
//! ```
//! Class {
//!     // 0xCAFEBABE
//!     magic: u32,
//!     minor_version: u16,
//!     major_version: u16,
//!
//!     constant_pool_count: u16,
//!     constant_pool: [Constant; constant_pool_count - 1],
//!
//!     access_flags: u16,
//!     this_class: u16,
//!     super_class: u16,
//!
//!     interfaces_count: u16,
//!     interfaces: [u16; interfaces_count],
//!
//!     fields_count: u16,
//!     fields: [Field; fields_count],
//!
//!     methods_count: u16,
//!     methods: [Method; methods_count],
//!
//!     attributes_count: u16,
//!     attributes: [Attribute; attributes_count],
//! }
//! ```

use crate::{
    attribute::{parse_attribute, AttributeInfo},
    constant::{parse_constant_pool, Constant},
    field::{parse_field, Field},
    method::{parse_method, Method},
    ByteParser, ClassError, ClassResult, ParseResult,
};

pub fn parse_version(input: &mut ByteParser<'_>) -> ParseResult<Version> {
    let minor = input.parse_u16()?;
    let major = input.parse_u16()?;
    Ok(Version { minor, major })
}

pub fn parse_access_flags(input: &mut ByteParser<'_>) -> ParseResult<Access> {
    Ok(Access(input.parse_u16()?))
}

/// The class file magic: `0xCAFEBABE`
pub const CLASS_MAGIC: &[u8; 4] = &[0xCA, 0xFE, 0xBA, 0xBE];

pub fn parse_class(input: &mut ByteParser<'_>) -> ClassResult<Class> {
    input.tag(CLASS_MAGIC)?;
    let version = parse_version(input)?;
    let pool = parse_constant_pool(input)?;
    let access_flags = parse_access_flags(input)?;
    let this_class = input.parse_u16()? as usize;
    let super_class = input.parse_u16()? as usize;

    let interfaces_len = input.parse_u16()? as usize;
    let interfaces = input.seq(interfaces_len, |input| {
        input.parse_u16().map(|x| x as usize)
    })?;

    let fields_len = input.parse_u16()? as usize;
    let fields = input.seq(fields_len, |input| parse_field(input, &pool))?;

    let methods_len = input.parse_u16()? as usize;
    let methods = input.seq(methods_len, |input| parse_method(input, &pool))?;

    let attributes_len = input.parse_u16()? as usize;
    let attributes = input.seq(attributes_len, |input| parse_attribute(input, &pool))?;

    Ok(Class {
        version,
        pool,
        access_flags,
        this_class,
        super_class,
        interfaces: interfaces.into(),
        fields: fields.into(),
        methods: methods.into(),
        attributes: attributes.into(),
    })
}

/// Access flags denote the properties of a given class file.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct Access(u16);

impl Access {
    /// The class is declared `abstract`; it cannot be directly instantiated. If
    /// this flag is set, then the `final` flag must not be set.
    pub const ABSTRACT: Access = Access(0x0400);
    /// The class is an annotation. If this flag is set, the `interface` flag
    /// must also be set.
    pub const ANNOTATION: Access = Access(0x2000);
    /// The class or a supertype of the class is an `enum`.
    pub const ENUM: Access = Access(0x4000);
    /// The class is desclared as `final`; no subclasses are allowed. If this
    /// flag is set, then the `abstract` flag must not be set.
    pub const FINAL: Access = Access(0x0010);
    /// The class is an `interface`. If this flag is set, the abstract flag must
    /// also be set. Additionally, the `final`, `super`, and `enum` flags must
    /// not be
    pub const INTERFACE: Access = Access(0x0200);
    /// The class is declared as `public`; it may be accessed from outside the
    /// current package.
    pub const PUBLIC: Access = Access(0x0001);
    /// Treat superclass methods specially when invoked by the invokespecial
    /// instruction.
    pub const SUPER: Access = Access(0x0020);
    /// The class does not appear in source code; it was generated by the
    /// compiler.
    pub const SYNTHETIC: Access = Access(0x1000);

    pub fn is(self, access: Access) -> bool {
        self & access != Access(0)
    }

    pub fn into_raw(self) -> u16 {
        self.0
    }
}

impl std::ops::BitAnd for Access {
    type Output = Access;

    fn bitand(self, other: Access) -> Access {
        Access(self.0 & other.0)
    }
}

impl std::ops::BitOr for Access {
    type Output = Access;

    fn bitor(self, other: Access) -> Access {
        Access(self.0 | other.0)
    }
}

impl std::fmt::Display for Access {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let mut was_written = false;
        let mut write = |s| {
            if was_written {
                write!(f, " {}", s)
            } else {
                write!(f, "{}", s)?;
                was_written = true;
                Ok(())
            }
        };

        if self.is(Access::PUBLIC) {
            write("public")?;
        }

        if self.is(Access::ENUM) {
            write("enum")?;
        } else if self.is(Access::ANNOTATION) {
            write("@interface")?;
        } else if self.is(Access::INTERFACE) {
            write("interface")?;
        } else {
            if self.is(Access::FINAL) {
                write("final")?;
            } else if self.is(Access::ABSTRACT) {
                write("abstract")?;
            }

            write("class")?;
        }

        Ok(())
    }
}

/// Version of the class file.
///
/// Versions are denoted as `M.m` where `M` is the
/// major version and `m` is the minor version. The version can be ordered
/// lexicographically. JVM implementations can choose a range of compatible
/// versions by selecting a minimum major version `Mi`, maximum major version
/// `Mj`, and a maximum minor version `m`. With these, the JVM can support
/// versions on the range `Mi.0 <= v <= Mj.m` for some arbitrary `v`.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Version {
    pub major: u16,
    pub minor: u16,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Class {
    pub version: Version,
    pub access_flags: Access,

    pub this_class: usize,
    pub super_class: usize,
    pub pool: Box<[Constant]>,

    pub interfaces: Box<[usize]>,
    pub fields: Box<[Field]>,
    pub methods: Box<[Method]>,
    pub attributes: Box<[AttributeInfo]>,
}

impl Class {
    pub fn parse<T: AsRef<[u8]>>(src: T) -> Result<Class, ClassError> {
        parse_class(&mut ByteParser::new(src.as_ref()))
    }
}
